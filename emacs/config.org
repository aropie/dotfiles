* General layout and config
** Defuse custom file
   I really dislike custom writing on init.el without my permission,
   so I disable it altogether
#+BEGIN_SRC emacs-lisp
(setq custom-file null-device)
#+END_SRC
** Mac alt fix
#+BEGIN_SRC emacs-lisp
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier nil)
#+END_SRC
** Mac path fix
   MacOs has problems with paths, so we need to add them manually
#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :ensure t
    :config
    (exec-path-from-shell-initialize))
#+END_SRC
** Disable menu, toolbar and scroll
   They are visual clutter once you get to know the keybindings (or create your own)
   #+BEGIN_SRC emacs-lisp
     (tool-bar-mode -1)
     (menu-bar-mode -1)
     (scroll-bar-mode -1)
   #+END_SRC
** Scroll conservatively
   Makes Emacs scroll more smoothly
   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 100)
   #+END_SRC
** Disable ring alert
   I haven't actually experienced the ring alert, but people often say it's quite
   annoying, so better be safe than sorry
   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC
** Startup message
   I prefer the scratch buffer to greet me when I (rarely) restart Emacs
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
   #+END_SRC
** Backup tweaks
   #+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.saves")))
  (setq backup-by-copying t)
  (setq delete-old-versions t
  kept-new-versions 6
  kept-old-versions 2
  version-control t)
  #+END_SRC
** Ediff
   Ediff setings so it wont messup my beautiful tilling wm
#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  ;; Make ediff split horizontally instead of vertically
  (setq ediff-split-window-function 'split-window-horizontally)
#+END_SRC
** Increase GC
   Emacs garbage collection is a fairly primitive stop-the-world type.
   This means, performance can benefit greatly by increasing the threshold
   of memory allocated before GC runs. By default, Emacs will initate GC every
   0.76 MB allocated. Since it's no longer 2002, we can bumb that a little.
   #+BEGIN_SRC emacs-lisp
     (setq gc-cons-threshold 20000000)
   #+END_SRC
** Transparency
   I like being able to see my wallpaper. Call me a romantic if you like
#+BEGIN_SRC emacs-lisp
     (set-frame-parameter (selected-frame) 'alpha '(95 95))
     (add-to-list 'default-frame-alist '(alpha 95 95))
#+END_SRC
** Disable cursors in other windows
   I find confusing having cursors on every window, so I just remove inactive ones
#+BEGIN_SRC emacs-lisp
(setq cursor-in-non-selected-windows nil)
#+END_SRC
** Help
   When opening a help window, always select that window
   afterwards and move focus to it.
#+BEGIN_SRC emacs-lisp
  (setq help-window-select t)
#+END_SRC
** Font
   This is supposed to adjust font sizes depending on which screen I'm
   working on, but I have yet to find a sweet spot for it
#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :height 100)
#+END_SRC
* EXWM
** Functions
#+BEGIN_SRC emacs-lisp
  (defun aropie/exwm-rename-buffer ()
    (let* ((part1 exwm-class-name)
	   (part2 (when (not (string-equal exwm-class-name exwm-title))
		    (concat "/" exwm-title)))
	   (name (concat part1 (or part2 "")))
	   (maxlen 40))
      (exwm-workspace-rename-buffer (if (> (length name) maxlen)
					(concat (subseq name 0 (- maxlen 3)) "...")
				      name))))
  (defun aropie/exwm-layout-toggle-fullscreen ()
    "Togggles full screen for Emacs and X windows"
    (interactive)
    (if exwm--id
	(if (exwm-layout--fullscreen-p)
	    (exwm-reset)
	  (exwm-layout-set-fullscreen))
      (spacemacs/toggle-maximize-buffer)))
  (defun aropie/exwm-jump-to-last-exwm ()
    (interactive)
    (exwm-workspace-switch exwm-toggle-workspace))
#+END_SRC
** Config
#+BEGIN_SRC emacs-lisp
    (use-package exwm
      :init
      ;; Disable dialog boxes since they are unusable in EXWM
      (setq use-dialog-box nil)
      ;; 10 Worskpaces please
      (setq exwm-workspace-number 1)
      ;; You may want Emacs to show you the time
      (display-time-mode t)
      :config

      (require 'exwm-config)
      (exwm-config-ido)

      ;; Quick swtiching between workspaces
      (defvar exwm-toggle-workspace 0
	"Previously selected workspace. Used with `aropie/exwm-jump-to-last-exwm'.")

      (defadvice exwm-workspace-switch (before save-toggle-workspace activate)
	(setq exwm-toggle-workspace exwm-workspace-current-index))

      (exwm-input-set-key (kbd "s-r") 'exwm-reset)
      (exwm-input-set-key (kbd "s-f") 'aropie/exwm-layout-toggle-fullscreen)
      (exwm-input-set-key (kbd "<s-tab>") 'aropie/exwm-jump-to-last-exwm)
      ;; + Bind a key to switch workspace interactively
      (exwm-input-set-key (kbd "s-w") 'exwm-workspace-switch)
      ;; + Set shortcuts to switch to a certain workspace.
      (exwm-input-set-key (kbd "s-1")
			  (lambda () (interactive) (exwm-workspace-switch-create 1)))
      (exwm-input-set-key (kbd "s-2")
			  (lambda () (interactive) (exwm-workspace-switch-create 2)))
      (exwm-input-set-key (kbd "s-3")
			  (lambda () (interactive) (exwm-workspace-switch-create 3)))
      (exwm-input-set-key (kbd "s-4")
			  (lambda () (interactive) (exwm-workspace-switch-create 4)))
      (exwm-input-set-key (kbd "s-5")
			  (lambda () (interactive) (exwm-workspace-switch-create 5)))
      (exwm-input-set-key (kbd "s-6")
			  (lambda () (interactive) (exwm-workspace-switch-create 6)))
      (exwm-input-set-key (kbd "s-7")
			  (lambda () (interactive) (exwm-workspace-switch-create 7)))
      (exwm-input-set-key (kbd "s-8")
			  (lambda () (interactive) (exwm-workspace-switch-create 8)))
      (exwm-input-set-key (kbd "s-9")
			  (lambda () (interactive) (exwm-workspace-switch-create 9)))
      (exwm-input-set-key (kbd "s-0")
			  (lambda () (interactive) (exwm-workspace-switch-create 0)))
      ;; User s-q to close buffers
      (exwm-input-set-key (kbd "s-q") 'kill-this-buffer)
      ;; Focusing windows
      (exwm-input-set-key (kbd "s-h") #'evil-window-left)
      (exwm-input-set-key (kbd "s-j") #'evil-window-down)
      (exwm-input-set-key (kbd "s-k") #'evil-window-up)
      (exwm-input-set-key (kbd "s-l") #'evil-window-right)
      ;; Moving Windows
      (exwm-input-set-key (kbd "s-H") #'evil-window-move-far-left)
      (exwm-input-set-key (kbd "s-J") #'evil-window-move-very-bottom)
      (exwm-input-set-key (kbd "s-K") #'evil-window-move-very-top)
      (exwm-input-set-key (kbd "s-L") #'evil-window-move-far-right)

      ;; C-c, C-x are needed for copying and pasting
      (delete ?\C-x exwm-input-prefix-keys)
      (delete ?\C-c exwm-input-prefix-keys)
      ;; We can use `M-m h' to access help
      (delete ?\C-h exwm-input-prefix-keys)

      ;; Map C-c C-c to C-c in EXWM buffers
      (add-hook 'exwm-manage-finish-hook
		(lambda ()
		  (when exwm-class-name
		    (exwm-input-set-local-simulation-keys '(([?\C-c ?\C-c] . ?\C-c))))))

      ;; Allow for s-SPC to work on char mode
      (push ?\s-\  exwm-input-prefix-keys)

      (add-hook 'exwm-update-class-hook 'aropie/exwm-rename-buffer)
      (add-hook 'exwm-update-title-hook 'aropie/exwm-rename-buffer)

  (require 'exwm-randr)
  (setq exwm-randr-workspace-output-plist '(1 "DP-0" 2 "DP-3" 3 "DP-0" 4 "DP-3" 5 "DP-3" 6 "DP-3" 7 "DP-3" 8 "DP-3" 9 "DP-3"))
  (exwm-randr-enable)

  (exwm-enable))
#+END_SRC
* Utils
** General.el
   Manage all the keybindings through general and hydra Ã  la spacemacs
*** Leaders definitions
#+BEGIN_SRC emacs-lisp
  (use-package general
    :ensure t
    :init
    (setq general-override-states '(insert
				  emacs
				  hybrid
				  normal
				  visual
				  motion
				  operator
				  replace))
    (general-override-mode)
    :config
    (general-create-definer my-leader
      ;; :prefix my-leader
      :keymaps 'override
      :prefix "s-SPC")
      (general-def '(normal visual motion) "SPC" (general-simulate-key "s-SPC"))
    (general-create-definer my-local-leader
      ;; prefix local-leader
      :prefix "s-SPC m"))
#+END_SRC
*** Overall bindings
#+BEGIN_SRC emacs-lisp
  (my-leader
   :keymaps 'normal
   "TAB" '(mode-line-other-buffer :which-key "Previous buffer")
   "m" '(:ignore t :which-key "Major mode")
   "f" '(find-file :which-key "Find file")
   "F" '(find-file-other-window :which-key "Find file (other window)")
   "s" '(save-buffer :which-key "Save buffer")
   "S" '(ido-write-file :which-key "Save as")
   "b" '(ido-switch-buffer :which-key "Switch buffer")
   "k" '(kill-this-buffer :which-key "Kill this buffer")
   "K" '(kill-buffer-and-window :which-key "Kill this buffer and window")
   "o" '(ace-window :which-key "Change window"))
#+END_SRC
** Config shortcuts
   I tend to modify a lot my config files, so I set shortcuts to the
   most used ones
*** Definitions
#+BEGIN_SRC emacs-lisp
  (defun aropie/emacs-config-visit ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))
  (defun aropie/i3-config-visit ()
    (interactive)
    (find-file "~/.config/i3/config"))
  (defun aropie/zsh-config-visit ()
    (interactive)
    (find-file "~/.zshrc"))
  (defun aropie/emacs-config-reload ()
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
#+END_SRC
*** Bindings
#+BEGIN_SRC emacs-lisp
  (my-leader
    :keymaps 'normal
    :infix "c"
    "" '(:ignore t :which-key "Config")
    "e" '(aropie/emacs-config-visit :which-key "emacs")
    "i" '(aropie/i3-config-visit :which-key "i3")
    "z" '(aropie/zsh-config-visit :which-key "zsh")
    "r" '(aropie/emacs-config-reload :which-key "Reload emacs config"))
#+END_SRC
** PDF-tools
   Because Emacs' default Doc-view mode sucks hard
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t
    :custom
    (pdf-view-display-size 'fit-page)
    :config
    (pdf-tools-install))
#+END_SRC
** Shell
   Because someday I wish to start using the shell within Emacs. Someday...
*** Don't ask for confirmation when killing shell
#+BEGIN_SRC emacs-lisp
  (defun set-no-process-query-on-exit ()
    (let ((proc (get-buffer-process (current-buffer))))
      (when (processp proc)
        (set-process-query-on-exit-flag proc nil))))

  (add-hook 'term-exec-hook 'set-no-process-query-on-exit)
#+END_SRC
** Try
   For when you're not sure wether you want a package polluting your system
#+BEGIN_SRC emacs-lisp
  (use-package try
    :ensure t)
#+END_SRC

** which-key
   Because Emacs is hard enough without visual aids
   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :ensure t
       :init
       (setq which-key-idle-delay 1)
       (which-key-mode)
       :delight)
   #+END_SRC
** Delight
#+BEGIN_SRC emacs-lisp
  (use-package delight
    :ensure t)
#+END_SRC
** Undo-tree
#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :delight)
#+END_SRC
** Hydra
#+BEGIN_SRC emacs-lisp
  (use-package hydra
    :ensure t)
#+END_SRC
** Projectile
   Ok, I'll admit it: Projectile's really cool. Really nice project management.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :custom
    (projectile-indexing-method 'native)
    (projectile-enable-caching t)
    :config
    (add-to-list 'projectile-globally-ignored-directories ".venv")
    (projectile-mode t)
    (my-leader
    :keymaps 'normal
    :infix "p"
    "" '(:ignore t :which-key "Project")
    "f" '(projectile-find-file :which-key "Find file")
    "F" '(projectile-find-file-other-window :which-key "Find file (other window)")
    "b" '(projectile-switch-to-buffer :which-key "Switch to buffer")
    "B" '(projectile-switch-to-buffer-other-window :which-key "Switch to buffer (other window)")
    "k" '(projectile-kill-buffers :which-key "Kill all project buffers")
    "p" '(projectile-switch-project :which-key "Switch to project")
    "t" '(projectile-toggle-between-implementation-and-test :which-key "Toggle between test and implementation")
    "T" '(projectile-test-project :which-key "Tun project's tests")
    "a" '(projectile-add-known-project :which-key "Add bookmark to project")
    "r" '(projectile-replace :which-key "Replace in project")
    "c" '(projectile-invalidate-cache :which-key "Clear project's cache")
    "s" '(projectile-grep :which-key "Search in project")))
#+END_SRC
* Completion
** Company
   My choice for auto-completion
 #+BEGIN_SRC emacs-lisp
      (use-package company
	:ensure t
	:delight
	:custom
	(company-begin-commands '(self-insert-command))
	(company-idle-delay 0)
	(company-minimum-prefix-length 2)
	(company-show-numbers t)
	(company--dabbrev-code-everywhere t)
	(company-dabbrev-downcase nil)
	(company-dabbrev-ignore-case t)
	(company-tooltip-align-annotations t)
	(company-frontends
	 '(company-tng-frontend
	   company-pseudo-tooltip-frontend
	   company-echo-metadata-frontend))
	(global-company-mode t)
	:config
	(company-tng-configure-default))
 #+END_SRC
** Company-jedi
    Python autocompletion
#+BEGIN_SRC emacs-lisp
  (use-package company-jedi
    :ensure t
    :after (company)
    :config
    (add-to-list 'company-backends 'company-jedi))
#+END_SRC
** Go-company
   Go autocompletion
 #+BEGIN_SRC emacs-lisp
   (use-package company-go
     :ensure t
     :after company
     :config
     (add-hook 'go-mode-hook
	       (lambda ()
		 (add-to-list 'company-backends 'company-go))))
 #+END_SRC
** Company-quickhelp
   Prompts a little toolbar with documentation of the completed
   item. Pretty neat
#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :ensure t
    :init
    (company-quickhelp-mode 1))
#+END_SRC
** IDO
   Because IDO's love (and Helm looks way too complicated)
*** Enable IDO mode
 #+BEGIN_SRC emacs-lisp
   (ido-mode t)
   (setq ido-everywhere t)
 #+END_SRC
*** Flex-matching for IDO
 A package that improves greatly on the default IDO's flex matching engine
 #+BEGIN_SRC emacs-lisp
   (use-package flx-ido
     :ensure t
     :config
     (flx-ido-mode t)
     (setq ido-enable-flex-matching t)
     (setq ido-use-faces nil))
 #+END_SRC
*** Smex
     IDO's replacement for M-x
 #+BEGIN_SRC emacs-lisp
   (use-package smex
     :ensure t
     :init (smex-initialize)
     :bind
     ("M-x" . smex))
 #+END_SRC
*** Grid
     Semi-vertical view of IDO
 #+BEGIN_SRC emacs-lisp
   (use-package ido-grid-mode
     :ensure t
     :init
     (ido-grid-mode t))
 #+END_SRC
* Editing
** Evil
   Embrace the anarchy. I love vim's modal editing. I hate vim as an editor
   #+BEGIN_SRC emacs-lisp
   (use-package evil
     :ensure t
     :init
     (setq evil-want-keybinding nil)
     :config
     (evil-mode 1)
     (fset 'evil-mouse-drag-region 'ignore))
 #+END_SRC
** Evil-collection
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :after evil
    :ensure t
    :config
    (add-to-list 'evil-collection-key-blacklist "SPC")
    (evil-collection-init))
#+END_SRC
** Evil-commentary
   Allows to comment word-objects
 #+BEGIN_SRC emacs-lisp
   (use-package evil-commentary
     :ensure t
     :init
     (evil-commentary-mode t)
     :delight)
 #+END_SRC
** Evil surround
   Allows to modify surroundings of word-objects
#+BEGIN_SRC emacs-lisp
  (use-package evil-surround
    :ensure t
    :init
    (global-evil-surround-mode t))
#+END_SRC
** Evil args
#+BEGIN_SRC emacs-lisp
  (use-package evil-args
    :ensure t
    :config
    ;; bind evil-args text objects
    (define-key evil-inner-text-objects-map "a" 'evil-inner-arg)
    (define-key evil-outer-text-objects-map "a" 'evil-outer-arg)

    ;; bind evil-forward/backward-args
    (define-key evil-normal-state-map "L" 'evil-forward-arg)
    (define-key evil-normal-state-map "H" 'evil-backward-arg)
    (define-key evil-motion-state-map "L" 'evil-forward-arg)
    (define-key evil-motion-state-map "H" 'evil-backward-arg))
#+END_SRC
** Evil exchange
   Allows for text objects exchanging
   #+BEGIN_SRC emacs-lisp
   (use-package evil-exchange
   :ensure t
   :config
   (evil-exchange-install))
   #+END_SRC
** Electric parenthesis
     Force the parenthesis to come in pairs, unlike you, dear reader
 #+BEGIN_SRC emacs-lisp
   (electric-pair-mode 1)
 #+END_SRC
** Flycheck
   Syntax checker and linter on the fly
 #+BEGIN_SRC emacs-lisp
   (use-package flycheck
     :ensure t
     :init (global-flycheck-mode)
     :delight)
 #+END_SRC
** Smart Tabs
    Allegedly, the correct way to indent. Unfortunately PEP8, forbids it
 #+BEGIN_SRC emacs-lisp
   (use-package smart-tabs-mode
     :ensure t
     :init
     (smart-tabs-insinuate 'c 'javascript 'ruby))
 #+END_SRC
** Yasnippet
   Smart way to insert templates
 #+BEGIN_SRC emacs-lisp
         (use-package yasnippet
           :ensure t
           :config
           (setq yas-snippet-dirs (append yas-snippet-dirs
                                          '("~/.emacs/snippets")))
           (setq yas-triggers-in-field t)

           (defun aropie/company-expand ()
             (interactive)
             (company-abort)
             (yas-expand))
           (bind-key "<backtab>" 'aropie/company-expand company-active-map)

           :init
           (yas-global-mode 1))
 #+END_SRC
** Remove whitespace
   This removes whitespace prior to saving
#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
* UI
** Spacemacs-theme
   I like how spacemacs looks, but it's way too convoluted for my
   taste, so I grab their theme
#+BEGIN_SRC emacs-lisp
(use-package spacemacs-common
    :ensure spacemacs-theme
    :config (load-theme 'spacemacs-dark t))
#+END_SRC
** Doom-modeline
   Nice replacement for default mode line
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
	:ensure t
	:hook (after-init . doom-modeline-mode)
	:config
	(set-face-attribute 'doom-modeline-evil-normal-state nil :foreground "skyblue2")
	(set-face-attribute 'doom-modeline-evil-insert-state nil :foreground "green"))
#+END_SRC
** All the icons
    We take advantage of running Emacs as a GUI, and get nice icons for it
 #+BEGIN_SRC emacs-lisp
   (use-package all-the-icons
     :ensure t)
 #+END_SRC
** Cursor colors
   Adds visual aid to the modeline to know which mode I'm in
 #+BEGIN_SRC emacs-lisp
   (setq evil-emacs-state-cursor '("red" bar))
   (setq evil-normal-state-cursor '("skyblue2" box))
   (setq evil-visual-state-cursor '("gray" box))
   (setq evil-insert-state-cursor '("green" bar))
   (setq evil-replace-state-cursor '("red" hollow))
   (setq evil-operator-state-cursor '("red" hollow))
 #+END_SRC
** Rainbow-delimiters
   Visual aid to know which parenthesis is paired to which
 #+BEGIN_SRC emacs-lisp
   (use-package rainbow-delimiters
     :ensure t
     :config
     (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
 #+END_SRC
** Show-paren
    Highlight matching parenthesis on selection
 #+BEGIN_SRC emacs-lisp
   (show-paren-mode t)
 #+END_SRC
** Indent guides
   Visual aid for indentation
 #+BEGIN_SRC emacs-lisp
   (use-package highlight-indent-guides
     :ensure t
     :delight
     :config
     (setq highlight-indent-guides-responsive 'top)
     (setq highlight-indent-guides-method 'character)
     (add-hook 'prog-mode-hook 'highlight-indent-guides-mode))
 #+END_SRC

** Line highlight
   Highlights current line to aid with quick cursor finding
 #+BEGIN_SRC emacs-lisp
   (global-hl-line-mode t)
 #+END_SRC
* Navigation
** Follow symlinks
   Stop asking if I want to follow a symlink
#+BEGIN_SRC emacs-lisp
(setq vc-follow-symlinks t)
#+END_SRC
** Avy
    Jump around like there's no tomorrow
 #+BEGIN_SRC emacs-lisp
    (use-package avy
      :ensure t
      :custom
      (avy-background t)
      (avy-all-windows t)
      :config
      (defun aropie/avy-jump-to-char-in-one-window()
	(interactive)
	(setq current-prefix-arg '(4)) ; C-u
	(call-interactively 'avy-goto-char))

      (my-leader 'normal
      "SPC" '(aropie/avy-jump-to-char-in-one-window :which-key "Jump to char"))

      (my-leader
	:keymaps 'normal
	:infix "j"
	"" '(:ignore t :which-key "Jump")
	"w" '(avy-goto-subword-1 :which-key "Jump to word")
	"l" '(avy-goto-line :which-key "Jump to line")
	"c" '(avy-goto-char :which-key "Jump to char")
	"m" '(:ignore t :which-key "Move...")
	"ml" '(avy-move-line :which-key "Move line")
	"mr" '(avy-move-region :which-key "Move region")
	"y" '(:ignore t :which-key "Yank...")
	"yl" '(avy-copy-line :which-key "Yank line")
	"yr" '(avy-copy-region :which-key "Yank region")
	"k" '(:ignore t :which-key "Kill...")
	"kr" '(avy-kill-region :which-key "Kill region between lines")
	"kl" '(avy-kill-whole-line :which-key "Kill line")))
 #+END_SRC
** Evil-avy
   Avy support for f, F, t, T in evil-mode
#+BEGIN_SRC emacs-lisp
  (use-package evil-avy
    :ensure t
    :config
    (evil-avy-mode t))
#+END_SRC
** Window management
*** Ace window
    Window managing made smart
  #+BEGIN_SRC emacs-lisp
    (use-package ace-window
      :ensure t
      :custom
      (aw-scope 'frame)
      (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)))
  #+END_SRC
*** Window resizing
#+BEGIN_SRC emacs-lisp
  (defhydra hydra-window-resize (:color pink)
    "Resize window"
    ("k" evil-window-increase-height "up")
    ("j" evil-window-decrease-height "down")
    ("h" evil-window-decrease-width "left")
    ("l" evil-window-increase-width "right")
    ("=" balance-windows "balance")
    ("o" ace-window "change window")
    ("q" nil "quit" :color blue))
#+END_SRC
*** Bindings
#+BEGIN_SRC emacs-lisp
    (my-leader
    :keymaps 'normal
    :infix "w"
	"" '(:ignore t :which-key "Windows")
	"s" '(ace-swap-window :which-key "Swap windows")
	"o" '(delete-other-windows :which-key "Delete other windows")
	"x" '(ace-delete-window :which-key "Delete window")
	"h" '(split-window-vertically :which-key "Split window horizontally")
	"v" '(split-window-horizontally :which-key "Split window vertically")
	"r" '(hydra-window-resize/body :which-key "Resize windows"))
#+END_SRC
** Dumb-jump
    Jump to definitions
 #+BEGIN_SRC emacs-lisp
   (use-package dumb-jump
     :ensure t
     :custom
     (dumb-jump-use-visible-window nil)
     :config
     (my-leader
       :keymaps 'normal
       :infix "d"
       "" '(:ignore t :which-key "Definition")
       "j" '(dumb-jump-go :which-key "Jump to definition")
       "o" '(dumb-jump-go-other-window :which-key "Jump to definition on the other window")
       "l" '(dumb-jump-quick-look :which-key "Look at definition on tooltip")
       "b" '(dumb-jump-back :which-key "Jump back to previous-to-jump position")))
 #+END_SRC
* Git
** Magit
   Git porcelain inside Emacs. Basically, git turned into loving hugs and
   kisses
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config)
#+END_SRC
** Timemachine
    Take your code for a travel through time (that is incidentally,
    highly dependant on your commits)
#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :after hydra
    :ensure t
    :config
    (defhydra hydra-timemachine (:color pink)
      "Time machine"
      ("n" git-timemachine-show-next-revision "next")
      ("p" git-timemachine-show-previous-revision "previous")
      ("c" git-timemachine-show-current-revision "current")
      ("b" git-timemachine-blame "blame")
      ("s" git-timemachine-switch-branch "switch branch")
      ("q" (kill-matching-buffers "timemachine" t t) "quit" :color blue))

    (add-hook 'git-timemachine-mode-hook
	      (lambda () (hydra-timemachine/body))))
#+END_SRC
** Evil magit
#+BEGIN_SRC emacs-lisp
  (use-package evil-magit
    :ensure t
    :after magit)
#+END_SRC
** Bindings
#+BEGIN_SRC emacs-lisp
  (my-leader
    :keymaps 'normal
    :infix "g"
    "" '(:ignore t :which-key "Git")
    "s" '(magit-status :which-key "Status")
    "m" '(magit-dispatch-popup :which-key "Menu")
    "b" '(magit-branch :which-key "Branch")
    "B" '(magit-blame :which-key "Blame")
    "l" '(magit-log :which-key "Log")
    "F" '(magit-pull :which-key "Pull")
    "t" '(git-timemachine :which-key "Travel through time"))
#+END_SRC

* Org
** Basic config
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
  (setq org-log-done t)
  (setq org-enforce-todo-dependencies t)
  (add-to-list 'org-structure-template-alist
	       '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC
** Agenda
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/org"))
#+END_SRC
** Org bullets
#+BEGIN_SRC emacs-lisp
    (use-package org-bullets
       :ensure t
       :config
       (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC
** Org-pomodoro
#+BEGIN_SRC emacs-lisp
  (use-package org-pomodoro
    :ensure t
    :config
    (setq org-pomodoro-ticking-sound-p t)
    (setq org-pomodoro-ticking-sound-states '(:pomodoro)))
#+END_SRC
** Twitter-bootstrap export
#+BEGIN_SRC emacs-lisp
  (use-package ox-twbs
    :ensure t)
#+END_SRC
** Org-capture
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c c") 'org-capture)
  (setq org-default-notes-file "~/org/refile.org")
#+END_SRC
** Refile
#+BEGIN_SRC emacs-lisp
  ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
				   (org-agenda-files :maxlevel . 9))))

  ; Use full outline paths for refile targets - we file directly with IDO
  (setq org-refile-use-outline-path t)

  ; Targets complete directly with IDO
  (setq org-outline-path-complete-in-steps nil)

  ; Allow refile to create parent tasks with confirmation
  (setq org-refile-allow-creating-parent-nodes (quote confirm))
#+END_SRC
* Languages
** Go
 #+BEGIN_SRC emacs-lisp
   (use-package go-mode
     :ensure t)
 #+END_SRC
** Web
 #+BEGIN_SRC emacs-lisp
   (use-package web-mode
     :ensure t
     :init
     (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
     (add-to-list 'auto-mode-alist '("\\.json\\'" . web-mode))
     :config
     (setq web-mode-markup-indent-offset 2)
     (setq web-mode-enable-auto-pairing t)
     (setq web-mode-enable-auto-quoting t)
     (setq web-mode-enable-auto-closing t)
     (setq web-mode-enable-engine-detection t)
     (setq web-mode-enable-css-colorization t))
 #+END_SRC
** Python
*** Docs
    Easy way to create standard docstrings
    #+BEGIN_SRC emacs-lisp
      (use-package sphinx-doc
	:ensure t
	:custom
	(flycheck-python-flake8-executable "flake8")
	:config
	(add-hook 'python-mode-hook (lambda ()
                                      (require 'sphinx-doc)
                                      (sphinx-doc-mode t)))
	(my-local-leader
	  :states 'normal
	  :keymaps 'python-mode-map
	  "d" '(sphinx-doc :which-key "Generate doc")))
    #+END_SRC
*** Black
    Gives a standard PEP8-compliant automated way to have a nice formatted Python code
    (requires pip install black)
#+BEGIN_SRC emacs-lisp
  (use-package blacken
    :ensure t
    :config
    (add-hook 'python-mode 'blacken-mode))
#+END_SRC
** Lisp
*** Slime
    Sane slime config. Taken from [[https://stackoverflow.com/questions/1101487/setting-up-a-working-common-lisp-environment-for-the-aspiring-lisp-newbie/1101605#1101605][here.]]
#+BEGIN_SRC emacs-lisp
  (use-package slime
    :ensure t
    :config
  (progn
       (setq slime-lisp-implementations
	     '((sbcl ("/usr/bin/sbcl"))
	       (ecl ("/usr/bin/ecl"))
	       (clisp ("/usr/bin/clisp"))))
       (slime-setup '(
		      slime-asdf
		      slime-autodoc
		      slime-editing-commands
		      slime-fancy-inspector
		      slime-fontifying-fu
		      slime-fuzzy
		      slime-indentation
		      slime-mdot-fu
		      slime-package-fu
		      slime-references
		      slime-repl
		      slime-sbcl-exts
		      slime-scratch
		      slime-xref-browser
		      ))
       (slime-autodoc-mode)
       (setq slime-complete-symbol*-fancy t)
       (setq slime-complete-symbol-function
    'slime-fuzzy-complete-symbol)))
#+END_SRC
* LOL
** Nyan mode
#+BEGIN_SRC emacs-lisp
  (use-package nyan-mode
    :ensure t
    :init
    (nyan-mode)
    (nyan-start-animation))
#+END_SRC
** Fireplace
#+BEGIN_SRC emacs-lisp
  (use-package fireplace
    :ensure t
    :disabled
    :init
    (run-with-idle-timer 600 t 'fireplace ()))
#+END_SRC
